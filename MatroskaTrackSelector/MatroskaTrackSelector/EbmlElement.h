#pragma once
#include <utility>
#include <unordered_map>

#include "Common.h"
#include "EbmlElementID.h"
#include "EbmlElementLength.h"
#include "MatroskaElementSpecification.h"
#include "BasicSharedPtr.h"
#include "ElementIterator.h"

using std::unordered_map;

class ElementIterator;

// Offsets relative to the current element
enum class EbmlOffset
{
    Header, // Offset to the first character of the EBML ID
    Data,   // Offset to the first character if the data (after EBML ID and Length)
    End     // Offset to the first character after the end of the data
};

class EbmlElement
{
public:
    // 'EbmlElement' object should be generated by this function and not by the constructors
    template <typename... Args>
    static BasicSharedPtr<EbmlElement> s_get(Args&&... args);

    // Construct an orphan element from stream in current position
    EbmlElement(std::iostream& stream);

    ~EbmlElement();

    /******************************************************************************************************/
    /********************************************** Getters ***********************************************/
    /******************************************************************************************************/
    EbmlElementID get_id() const { return m_id; }
    EbmlElementLength get_length() const { return m_length; }

public:
    /******************************************************************************************************/
    /******************************************* Iterator Stuff *******************************************/
    /******************************************************************************************************/
    ElementIterator begin();
    constexpr void* end() { return nullptr; }

public:
    /******************************************************************************************************/
    /*************************************** Functions for iteration **************************************/
    /******************************************************************************************************/
    BasicSharedPtr<EbmlElement> get_next_element();
    BasicSharedPtr<EbmlElement> get_first_child();

    bool is_last() { return this->_get_offset(EbmlOffset::End) == m_parent->_get_offset(EbmlOffset::End); }

    void find_children(unordered_map<EbmlElementIDType, BasicSharedPtr<EbmlElement>>& children);

    /*??????*/
    void initialize_as_root();

private:
    // Construct an element from the position of the parent's stream
    EbmlElement(BasicSharedPtr<EbmlElement> parent);

    /******************************************************************************************************/
    /****************************************** Internal Utility ******************************************/
    /******************************************************************************************************/
    constexpr uint64_t _get_offset(EbmlOffset seek_pos) const;
    inline void _seek_to(EbmlOffset seek_pos) const;
    inline void _seek_to(uint64_t seek_pos) const;

private:
    std::iostream& m_stream;
    uint64_t m_offset;
    EbmlElementID m_id;
    EbmlElementLength m_length;
    BasicSharedPtr<EbmlElement> m_parent;   // Owned
    BasicSharedPtr<EbmlElement> m_self;     // Not owned

public:
    friend class BasicSharedPtr<EbmlElement>;
};

template<typename ...Args>
inline BasicSharedPtr<EbmlElement> EbmlElement::s_get(Args&& ...args)
{
    BasicSharedPtr<EbmlElement> result = BasicSharedPtr<EbmlElement>::make_basic_shared(std::forward<Args>(args)...);
    result->m_self = result;
    result->m_self.release_ownership();
    return result;
}